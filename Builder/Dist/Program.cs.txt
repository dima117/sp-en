//10/15/2023 1:21:28 AM
public static class Helpers{public class InterceptResult{public Vector3D Position;public double TimeMs;}public static InterceptResult CalculateInterceptPoint(Vector3D ownPosition,double interceptSpeed,Vector3D targetPosition,Vector3D targetVelocity){Vector3D directionToTarget=Vector3D.Normalize(targetPosition-ownPosition);double targetSpeedlOrth=Vector3D.Dot(targetVelocity,directionToTarget);Vector3D targetVelOrth=directionToTarget*targetSpeedlOrth;Vector3D targetVelTang=targetVelocity-targetVelOrth;double targetSpeedlTang=targetVelTang.Length();if(targetSpeedlTang>=interceptSpeed){return null;}double missileSpeedTang=targetSpeedlTang;double missileSpeedOrth=Math.Sqrt(interceptSpeed*interceptSpeed-missileSpeedTang*missileSpeedTang);if(targetSpeedlOrth>=missileSpeedOrth){return null;}double timeS=Vector3D.Distance(ownPosition,targetPosition)/(missileSpeedOrth-targetSpeedlOrth);Vector3D point=targetPosition+targetVelocity*timeS;return new InterceptResult{Position=point,TimeMs=timeS*1000};}}public class DirectionController2{public const double MIN_SPEED=50;readonly IMyShipController remoteControl;readonly IEnumerable<IMyGyro>gyroList;readonly float factor;public DirectionController2(IMyShipController remoteControl,IEnumerable<IMyGyro>gyroList,float factor){this.remoteControl=remoteControl;this.gyroList=gyroList;this.factor=factor;}public void ICBM(Vector3D targetPos){var grav=remoteControl.GetNaturalGravity();if(!grav.IsZero()){var ownPos=remoteControl.GetPosition();var targetVector=targetPos-ownPos;Vector3D direction;if(targetVector.Length()>3500){direction=CompensateSideVelocity(grav,targetVector);}else{var velocity=remoteControl.GetShipVelocities().LinearVelocity;direction=CompensateSideVelocity(velocity,targetVector,1.5f);}var axis=GetAxis(remoteControl.WorldMatrix.Forward,direction);SetGyroByAxis(axis);}}public void KeepHorizon(){var grav=remoteControl.GetNaturalGravity();if(!grav.IsZero()){var axis=GetAxis(remoteControl.WorldMatrix.Down,grav);SetGyroByAxis(axis);}}public void Aim(Vector3D targetPos){var ownPos=remoteControl.GetPosition();var velocity=remoteControl.GetShipVelocities().LinearVelocity;var targetVector=CompensateSideVelocity(velocity,targetPos-ownPos);var axis=GetAxis(remoteControl.WorldMatrix.Forward,targetVector);SetGyroByAxis(axis);}public void Intercept(MyDetectedEntityInfo target){var ownPos=remoteControl.GetPosition();var velocity=remoteControl.GetShipVelocities().LinearVelocity;var ownSpeed=Math.Max(velocity.Length(),MIN_SPEED);var point=Helpers.CalculateInterceptPoint(ownPos,ownSpeed,target.Position,target.Velocity);var direction=point==null?new Vector3D(target.Velocity):(point.Position-ownPos);var targetVector=CompensateSideVelocity(velocity,direction);var axis=GetAxis(remoteControl.WorldMatrix.Forward,targetVector);SetGyroByAxis(axis);}public static Vector3D CompensateSideVelocity(Vector3D velocity,Vector3D targetVector,float ratio=1){var sideVelocity=Vector3D.Reject(velocity,Vector3D.Normalize(targetVector));var sameDirection=Vector3D.Dot(velocity,targetVector)>0;return sameDirection?velocity-(1+ratio)*sideVelocity:(1-ratio)*sideVelocity-velocity;}public static Vector3D GetAxis(Vector3D currentDirection,Vector3D targetDirection){var target=Vector3D.Normalize(targetDirection);var current=Vector3D.Normalize(currentDirection);var axis=target.Cross(current);if(target.Dot(current)<0){axis=Vector3D.Normalize(axis);}return axis;}public void SetGyroByAxis(Vector3D axis){foreach(var gyro in gyroList){gyro.Yaw=factor*Convert.ToSingle(axis.Dot(gyro.WorldMatrix.Up));gyro.Pitch=factor*Convert.ToSingle(axis.Dot(gyro.WorldMatrix.Right));gyro.Roll=factor*Convert.ToSingle(axis.Dot(gyro.WorldMatrix.Backward));}}}public class BlockArray<T>where T:class,IMyTerminalBlock{MyGridProgram program;Action<T>init;private List<T>list=new List<T>();private int index=0;public int Count=>list.Count;public BlockArray(MyGridProgram program,Action<T>init=null){this.program=program;this.init=init;UpdateBlocks();}public void UpdateBlocks(){list=new List<T>();index=0;var tmp=new List<IMyTerminalBlock>();program.GridTerminalSystem.GetBlocks(tmp);foreach(var x in tmp){var block=x as T;if(block!=null){list.Add(block);init(block);}}}public void ForEach(Action<T>fn=null){if(fn!=null){list.ForEach(fn);}}public T GetNext(Func<T,bool>filter=null){for(var count=0;count<list.Count;count++){index++;if(index>=list.Count){index=0;}T block=list[index];if(filter==null||filter(block)){return block;}}return null;}}public class TargetTracker{const double DISTANCE_RESERVE=50;const double DISTANCE_SCAN_DEFAULT=5000;static readonly HashSet<MyDetectedEntityType>targetTypes=new HashSet<MyDetectedEntityType>{MyDetectedEntityType.SmallGrid,MyDetectedEntityType.LargeGrid};public struct TargetInfo{public readonly MyDetectedEntityInfo Entity;public readonly Vector3D HitPos;public readonly DateTime Timestamp;public readonly double ScanDelayMs;public TargetInfo(MyDetectedEntityInfo entity=default(MyDetectedEntityInfo),DateTime timestamp=default(DateTime),double scanDelayMs=default(double),Vector3D hitPos=default(Vector3D)){Entity=entity;Timestamp=timestamp;ScanDelayMs=scanDelayMs;HitPos=hitPos;}public TargetInfo Update(MyDetectedEntityInfo entity,DateTime timestamp,double scanDelayMs){return new TargetInfo(entity,timestamp,scanDelayMs,HitPos);}}public static TargetInfo?Scan(IMyCameraBlock cam,double distance=DISTANCE_SCAN_DEFAULT,bool onlyEnemies=false){if(cam==null){return null;}var target=cam.Raycast(distance);if(target.IsEmpty()){return null;}if(!targetTypes.Contains(target.Type)){return null;}if(onlyEnemies&&target.Relationship!=MyRelationsBetweenPlayerAndBlock.Enemies){return null;}var relativeHitPos=default(Vector3D);if(target.HitPosition.HasValue){var hitPos=target.HitPosition.Value;var camPos=cam.GetPosition();var correctedHitPos=hitPos+Vector3D.Normalize(hitPos-camPos);var invertedMatrix=MatrixD.Invert(target.Orientation);relativeHitPos=Vector3D.Transform(correctedHitPos-target.Position,invertedMatrix);}return new TargetInfo(target,DateTime.UtcNow,0,relativeHitPos);}private BlockArray<IMyCameraBlock>camArray;public TargetInfo?Current;static Vector3D CalculateTargetLocation(TargetInfo info,TimeSpan timePassed){var target=info.Entity;return target.Position+(target.Velocity*Convert.ToSingle(timePassed.TotalSeconds))+Vector3D.Transform(info.HitPos,target.Orientation);}public TargetTracker(MyGridProgram program){camArray=new BlockArray<IMyCameraBlock>(program,cam=>cam.EnableRaycast=true);}public int Count{get{return camArray.Count;}}public void UpdateCamArray(){camArray.UpdateBlocks();}public void LockOn(TargetInfo target){Current=target;}public void Clear(){Current=null;}private TargetInfo?TryGetUpdatedEntity(TargetInfo prevTarget,TimeSpan timePassed,DateTime now){var calculatedTargetPos=CalculateTargetLocation(prevTarget,timePassed);var camera=camArray.GetNext(cam=>cam.CanScan(calculatedTargetPos));if(camera==null){return null;}var target=camera.Raycast(calculatedTargetPos);if(target.IsEmpty()||target.EntityId!=prevTarget.Entity.EntityId){return null;}var camPos=camera.GetPosition();var distance=(target.Position-camPos).Length()+DISTANCE_RESERVE;var scanDelayMs=distance/camArray.Count/2;return prevTarget.Update(target,now,scanDelayMs);}public void Update(){if(!Current.HasValue){return;}var now=DateTime.UtcNow;var prevTarget=Current.Value;var timePassed=now-prevTarget.Timestamp;if(timePassed.TotalMilliseconds<prevTarget.ScanDelayMs){return;}var target=TryGetUpdatedEntity(prevTarget,timePassed,now);if(target.HasValue){Current=target.Value;}else if(timePassed.TotalSeconds>2){Clear();}}}public class Torpedo{public readonly string Id=DateTime.UtcNow.Ticks.ToString();readonly int delay;readonly int lifespan;readonly DirectionController2 tControl;readonly List<IMyGyro>listGyro=new List<IMyGyro>();readonly List<IMyThrust>listEngine=new List<IMyThrust>();readonly IMyRemoteControl tRemote;readonly IMyShipMergeBlock tClamp;DateTime startTime=DateTime.MaxValue;DateTime deathTime=DateTime.MaxValue;public Vector3D Position=>tRemote.GetPosition();public double Speed=>Started&&IsAlive?tRemote.GetShipSpeed():0;public bool IsReady=>listEngine.Any()&&listGyro.Any()&&tRemote!=null&&tClamp!=null;public bool Started{get;private set;}public long EntityId=>(tRemote?.EntityId).GetValueOrDefault();public bool IsAlive=>tRemote.IsFunctional&&listEngine.All(e=>e.IsFunctional&&e.CubeGrid.EntityId==tRemote.CubeGrid.EntityId)&&listGyro.All(g=>g.IsFunctional&&g.CubeGrid.EntityId==tRemote.CubeGrid.EntityId)&&DateTime.UtcNow<deathTime;public Torpedo(IMyBlockGroup group,int delay=3000,float factor=7,int lifespan=360){group.GetBlocksOfType(listGyro);group.GetBlocksOfType(listEngine);var tmp=new List<IMyTerminalBlock>();group.GetBlocks(tmp);tClamp=tmp.FirstOrDefault(b=>b is IMyShipMergeBlock)as IMyShipMergeBlock;tRemote=tmp.FirstOrDefault(b=>b is IMyRemoteControl)as IMyRemoteControl;tControl=new DirectionController2(tRemote,listGyro,factor);this.delay=delay;this.lifespan=lifespan;}public void Start(){startTime=DateTime.UtcNow;deathTime=startTime.AddSeconds(lifespan);tClamp.Enabled=false;listGyro.ForEach(g=>{g.GyroOverride=true;});listEngine.ForEach(e=>{e.Enabled=true;e.ThrustOverridePercentage=1;});Started=true;}public void Update(TargetTracker.TargetInfo?info){if((DateTime.UtcNow-startTime).TotalMilliseconds>delay){if(info.HasValue){var target=info.Value.Entity;tControl.Intercept(target);}}}}public class WcPbApi{public static WcPbApi Instance=new WcPbApi();public IMyTerminalBlock pBlock{get;private set;}private Action<ICollection<MyDefinitionId>>_getCoreWeapons;private Action<ICollection<MyDefinitionId>>_getCoreStaticLaunchers;private Action<ICollection<MyDefinitionId>>_getCoreTurrets;private Func<IMyTerminalBlock,IDictionary<string,int>,bool>_getBlockWeaponMap;private Func<long,MyTuple<bool,int,int>>_getProjectilesLockedOn;private Action<IMyTerminalBlock,IDictionary<MyDetectedEntityInfo,float>>_getSortedThreats;private Action<IMyTerminalBlock,ICollection<MyDetectedEntityInfo>>_getObstructions;private Func<long,int,MyDetectedEntityInfo>_getAiFocus;private Func<IMyTerminalBlock,long,int,bool>_setAiFocus;private Func<IMyTerminalBlock,long,bool>_releaseAiFocus;private Func<IMyTerminalBlock,int,MyDetectedEntityInfo>_getWeaponTarget;private Action<IMyTerminalBlock,long,int>_setWeaponTarget;private Action<IMyTerminalBlock,bool,int>_fireWeaponOnce;private Action<IMyTerminalBlock,bool,bool,int>_toggleWeaponFire;private Func<IMyTerminalBlock,int,bool,bool,bool>_isWeaponReadyToFire;private Func<IMyTerminalBlock,int,float>_getMaxWeaponRange;private Func<IMyTerminalBlock,ICollection<string>,int,bool>_getTurretTargetTypes;private Action<IMyTerminalBlock,ICollection<string>,int>_setTurretTargetTypes;private Action<IMyTerminalBlock,float>_setBlockTrackingRange;private Func<IMyTerminalBlock,long,int,bool>_isTargetAligned;private Func<IMyTerminalBlock,long,int,MyTuple<bool,Vector3D?>>_isTargetAlignedExtended;private Func<IMyTerminalBlock,long,int,bool>_canShootTarget;private Func<IMyTerminalBlock,long,int,Vector3D?>_getPredictedTargetPos;private Func<IMyTerminalBlock,float>_getHeatLevel;private Func<IMyTerminalBlock,float>_currentPowerConsumption;private Func<MyDefinitionId,float>_getMaxPower;private Func<long,bool>_hasGridAi;private Func<IMyTerminalBlock,bool>_hasCoreWeapon;private Func<long,float>_getOptimalDps;private Func<IMyTerminalBlock,int,string>_getActiveAmmo;private Action<IMyTerminalBlock,int,string>_setActiveAmmo;private Action<IMyTerminalBlock,int,Action<long,int,ulong,long,Vector3D,bool>>_monitorProjectile;private Action<IMyTerminalBlock,int,Action<long,int,ulong,long,Vector3D,bool>>_unMonitorProjectile;private Func<ulong,MyTuple<Vector3D,Vector3D,float,float,long,string>>_getProjectileState;private Func<long,float>_getConstructEffectiveDps;private Func<IMyTerminalBlock,long>_getPlayerController;private Func<IMyTerminalBlock,int,Matrix>_getWeaponAzimuthMatrix;private Func<IMyTerminalBlock,int,Matrix>_getWeaponElevationMatrix;private Func<IMyTerminalBlock,long,bool,bool,bool>_isTargetValid;private Func<IMyTerminalBlock,int,MyTuple<Vector3D,Vector3D>>_getWeaponScope;private Func<IMyTerminalBlock,MyTuple<bool,bool>>_isInRange;private Action<IMyTerminalBlock,int,Action<int,bool>>_monitorEvents;private Action<IMyTerminalBlock,int,Action<int,bool>>_unmonitorEvents;public bool Activate(IMyTerminalBlock pBlock){this.pBlock=pBlock;var dict=pBlock.GetProperty("WcPbAPI")?.As<IReadOnlyDictionary<string,Delegate>>().GetValue(pBlock);if(dict==null)throw new Exception("WcPbAPI failed to activate");return ApiAssign(dict);}public bool ApiAssign(IReadOnlyDictionary<string,Delegate>delegates){if(delegates==null)return false;AssignMethod(delegates,"GetCoreWeapons",ref _getCoreWeapons);AssignMethod(delegates,"GetCoreStaticLaunchers",ref _getCoreStaticLaunchers);AssignMethod(delegates,"GetCoreTurrets",ref _getCoreTurrets);AssignMethod(delegates,"GetBlockWeaponMap",ref _getBlockWeaponMap);AssignMethod(delegates,"GetProjectilesLockedOn",ref _getProjectilesLockedOn);AssignMethod(delegates,"GetSortedThreats",ref _getSortedThreats);AssignMethod(delegates,"GetObstructions",ref _getObstructions);AssignMethod(delegates,"GetAiFocus",ref _getAiFocus);AssignMethod(delegates,"SetAiFocus",ref _setAiFocus);AssignMethod(delegates,"ReleaseAiFocus",ref _releaseAiFocus);AssignMethod(delegates,"GetWeaponTarget",ref _getWeaponTarget);AssignMethod(delegates,"SetWeaponTarget",ref _setWeaponTarget);AssignMethod(delegates,"FireWeaponOnce",ref _fireWeaponOnce);AssignMethod(delegates,"ToggleWeaponFire",ref _toggleWeaponFire);AssignMethod(delegates,"IsWeaponReadyToFire",ref _isWeaponReadyToFire);AssignMethod(delegates,"GetMaxWeaponRange",ref _getMaxWeaponRange);AssignMethod(delegates,"GetTurretTargetTypes",ref _getTurretTargetTypes);AssignMethod(delegates,"SetTurretTargetTypes",ref _setTurretTargetTypes);AssignMethod(delegates,"SetBlockTrackingRange",ref _setBlockTrackingRange);AssignMethod(delegates,"IsTargetAligned",ref _isTargetAligned);AssignMethod(delegates,"IsTargetAlignedExtended",ref _isTargetAlignedExtended);AssignMethod(delegates,"CanShootTarget",ref _canShootTarget);AssignMethod(delegates,"GetPredictedTargetPosition",ref _getPredictedTargetPos);AssignMethod(delegates,"GetHeatLevel",ref _getHeatLevel);AssignMethod(delegates,"GetCurrentPower",ref _currentPowerConsumption);AssignMethod(delegates,"GetMaxPower",ref _getMaxPower);AssignMethod(delegates,"HasGridAi",ref _hasGridAi);AssignMethod(delegates,"HasCoreWeapon",ref _hasCoreWeapon);AssignMethod(delegates,"GetOptimalDps",ref _getOptimalDps);AssignMethod(delegates,"GetActiveAmmo",ref _getActiveAmmo);AssignMethod(delegates,"SetActiveAmmo",ref _setActiveAmmo);AssignMethod(delegates,"MonitorProjectile",ref _monitorProjectile);AssignMethod(delegates,"UnMonitorProjectile",ref _unMonitorProjectile);AssignMethod(delegates,"GetProjectileState",ref _getProjectileState);AssignMethod(delegates,"GetConstructEffectiveDps",ref _getConstructEffectiveDps);AssignMethod(delegates,"GetPlayerController",ref _getPlayerController);AssignMethod(delegates,"GetWeaponAzimuthMatrix",ref _getWeaponAzimuthMatrix);AssignMethod(delegates,"GetWeaponElevationMatrix",ref _getWeaponElevationMatrix);AssignMethod(delegates,"IsTargetValid",ref _isTargetValid);AssignMethod(delegates,"GetWeaponScope",ref _getWeaponScope);AssignMethod(delegates,"IsInRange",ref _isInRange);AssignMethod(delegates,"RegisterEventMonitor",ref _monitorEvents);AssignMethod(delegates,"UnRegisterEventMonitor",ref _unmonitorEvents);return true;}private void AssignMethod<T>(IReadOnlyDictionary<string,Delegate>delegates,string name,ref T field)where T:class{if(delegates==null){field=null;return;}Delegate del;if(!delegates.TryGetValue(name,out del))throw new Exception($"{GetType().Name} :: Couldn't find {name} delegate of type {typeof(T)}");field=del as T;if(field==null)throw new Exception($"{GetType().Name} :: Delegate {name} is not type {typeof(T)}, instead it's: {del.GetType()}");}public void GetAllCoreWeapons(ICollection<MyDefinitionId>collection)=>_getCoreWeapons?.Invoke(collection);public void GetAllCoreStaticLaunchers(ICollection<MyDefinitionId>collection)=>_getCoreStaticLaunchers?.Invoke(collection);public void GetAllCoreTurrets(ICollection<MyDefinitionId>collection)=>_getCoreTurrets?.Invoke(collection);public bool GetBlockWeaponMap(IMyTerminalBlock weaponBlock,IDictionary<string,int>collection)=>_getBlockWeaponMap?.Invoke(weaponBlock,collection)??false;public MyTuple<bool,int,int>GetProjectilesLockedOn(long victim)=>_getProjectilesLockedOn?.Invoke(victim)??new MyTuple<bool,int,int>();public void GetSortedThreats(IDictionary<MyDetectedEntityInfo,float>collection)=>_getSortedThreats?.Invoke(pBlock,collection);public void GetObstructions(ICollection<Sandbox.ModAPI.Ingame.MyDetectedEntityInfo>collection)=>_getObstructions?.Invoke(pBlock,collection);public MyDetectedEntityInfo?GetAiFocus(long shooter,int priority=0)=>_getAiFocus?.Invoke(shooter,priority);public bool SetAiFocus(long target,int priority=0)=>_setAiFocus?.Invoke(pBlock,target,priority)??false;public bool ReleaseAiFocus(long playerId)=>_releaseAiFocus?.Invoke(pBlock,playerId)??false;public MyDetectedEntityInfo?GetWeaponTarget(IMyTerminalBlock weapon,int weaponId=0)=>_getWeaponTarget?.Invoke(weapon,weaponId);public void SetWeaponTarget(IMyTerminalBlock weapon,long target,int weaponId=0)=>_setWeaponTarget?.Invoke(weapon,target,weaponId);public void FireWeaponOnce(IMyTerminalBlock weapon,bool allWeapons=true,int weaponId=0)=>_fireWeaponOnce?.Invoke(weapon,allWeapons,weaponId);public void ToggleWeaponFire(IMyTerminalBlock weapon,bool on,bool allWeapons,int weaponId=0)=>_toggleWeaponFire?.Invoke(weapon,on,allWeapons,weaponId);public bool IsWeaponReadyToFire(IMyTerminalBlock weapon,int weaponId=0,bool anyWeaponReady=true,bool shootReady=false)=>_isWeaponReadyToFire?.Invoke(weapon,weaponId,anyWeaponReady,shootReady)??false;public float GetMaxWeaponRange(IMyTerminalBlock weapon,int weaponId)=>_getMaxWeaponRange?.Invoke(weapon,weaponId)??0f;public bool GetTurretTargetTypes(IMyTerminalBlock weapon,IList<string>collection,int weaponId=0)=>_getTurretTargetTypes?.Invoke(weapon,collection,weaponId)??false;public void SetTurretTargetTypes(IMyTerminalBlock weapon,IList<string>collection,int weaponId=0)=>_setTurretTargetTypes?.Invoke(weapon,collection,weaponId);public void SetBlockTrackingRange(IMyTerminalBlock weapon,float range)=>_setBlockTrackingRange?.Invoke(weapon,range);public bool IsTargetAligned(IMyTerminalBlock weapon,long targetEnt,int weaponId)=>_isTargetAligned?.Invoke(weapon,targetEnt,weaponId)??false;public MyTuple<bool,Vector3D?>IsTargetAlignedExtended(IMyTerminalBlock weapon,long targetEnt,int weaponId)=>_isTargetAlignedExtended?.Invoke(weapon,targetEnt,weaponId)??new MyTuple<bool,Vector3D?>();public bool CanShootTarget(IMyTerminalBlock weapon,long targetEnt,int weaponId)=>_canShootTarget?.Invoke(weapon,targetEnt,weaponId)??false;public Vector3D?GetPredictedTargetPosition(IMyTerminalBlock weapon,long targetEnt,int weaponId)=>_getPredictedTargetPos?.Invoke(weapon,targetEnt,weaponId)??null;public float GetHeatLevel(IMyTerminalBlock weapon)=>_getHeatLevel?.Invoke(weapon)??0f;public float GetCurrentPower(IMyTerminalBlock weapon)=>_currentPowerConsumption?.Invoke(weapon)??0f;public float GetMaxPower(MyDefinitionId weaponDef)=>_getMaxPower?.Invoke(weaponDef)??0f;public bool HasGridAi(long entity)=>_hasGridAi?.Invoke(entity)??false;public bool HasCoreWeapon(IMyTerminalBlock weapon)=>_hasCoreWeapon?.Invoke(weapon)??false;public float GetOptimalDps(long entity)=>_getOptimalDps?.Invoke(entity)??0f;public string GetActiveAmmo(IMyTerminalBlock weapon,int weaponId)=>_getActiveAmmo?.Invoke(weapon,weaponId)??null;public void SetActiveAmmo(IMyTerminalBlock weapon,int weaponId,string ammoType)=>_setActiveAmmo?.Invoke(weapon,weaponId,ammoType);public void MonitorProjectileCallback(IMyTerminalBlock weapon,int weaponId,Action<long,int,ulong,long,Vector3D,bool>action)=>_monitorProjectile?.Invoke(weapon,weaponId,action);public void UnMonitorProjectileCallback(IMyTerminalBlock weapon,int weaponId,Action<long,int,ulong,long,Vector3D,bool>action)=>_unMonitorProjectile?.Invoke(weapon,weaponId,action);public MyTuple<Vector3D,Vector3D,float,float,long,string>GetProjectileState(ulong projectileId)=>_getProjectileState?.Invoke(projectileId)??new MyTuple<Vector3D,Vector3D,float,float,long,string>();public float GetConstructEffectiveDps(long entity)=>_getConstructEffectiveDps?.Invoke(entity)??0f;public long GetPlayerController(IMyTerminalBlock weapon)=>_getPlayerController?.Invoke(weapon)??-1;public Matrix GetWeaponAzimuthMatrix(IMyTerminalBlock weapon,int weaponId)=>_getWeaponAzimuthMatrix?.Invoke(weapon,weaponId)??Matrix.Zero;public Matrix GetWeaponElevationMatrix(IMyTerminalBlock weapon,int weaponId)=>_getWeaponElevationMatrix?.Invoke(weapon,weaponId)??Matrix.Zero;public bool IsTargetValid(IMyTerminalBlock weapon,long targetId,bool onlyThreats,bool checkRelations)=>_isTargetValid?.Invoke(weapon,targetId,onlyThreats,checkRelations)??false;public MyTuple<Vector3D,Vector3D>GetWeaponScope(IMyTerminalBlock weapon,int weaponId)=>_getWeaponScope?.Invoke(weapon,weaponId)??new MyTuple<Vector3D,Vector3D>();public MyTuple<bool,bool>IsInRange(IMyTerminalBlock block)=>_isInRange?.Invoke(block)??new MyTuple<bool,bool>();public void MonitorEvents(IMyTerminalBlock entity,int partId,Action<int,bool>action)=>_monitorEvents?.Invoke(entity,partId,action);public void UnMonitorEvents(IMyTerminalBlock entity,int partId,Action<int,bool>action)=>_unmonitorEvents?.Invoke(entity,partId,action);}public class WcRadar{private readonly Dictionary<MyDetectedEntityInfo,float>threats;public WcRadar(){threats=new Dictionary<MyDetectedEntityInfo,float>();}public void Update(){threats.Clear();WcPbApi.Instance.GetSortedThreats(threats);}public MyDetectedEntityInfo[]Threats=>threats.Keys.ToArray();public bool IsEmpty=>!threats.Any();public override string ToString(){var pos=WcPbApi.Instance.pBlock.GetPosition();var sb=new StringBuilder();foreach(var obj in threats){var entity=obj.Key;var distance=(entity.Position-pos).Length();sb.AppendFormat("{0} {1} :: D {2:0}m :: S {3:0}m/s\n",entity.Type,entity.EntityId,distance,entity.Velocity.Length());}return sb.ToString();}}TargetTracker tt;IMyCameraBlock cam;List<Torpedo>torpedos=new List<Torpedo>();List<IMyShipWelder>welders=new List<IMyShipWelder>();IMyTextPanel lcd1;IMyTextPanel lcd2;IMyTextPanel lcd3;IMyTextPanel lcd4;IMySoundBlock sound;WcRadar radar;bool onlyEnemies=false;public Program(){WcPbApi.Instance.Activate(Me);tt=new TargetTracker(this);radar=new WcRadar();cam=GridTerminalSystem.GetBlockWithName("MAIN_CAM")as IMyCameraBlock;cam.EnableRaycast=true;GridTerminalSystem.GetBlocksOfType(welders,w=>w.CustomName.StartsWith("T_WELDER_"));lcd1=GridTerminalSystem.GetBlockWithName("LCD1")as IMyTextPanel;lcd2=GridTerminalSystem.GetBlockWithName("LCD2")as IMyTextPanel;lcd3=GridTerminalSystem.GetBlockWithName("LCD3")as IMyTextPanel;lcd4=GridTerminalSystem.GetBlockWithName("LCD4")as IMyTextPanel;sound=GridTerminalSystem.GetBlockWithName("T_SOUND")as IMySoundBlock;Me.GetSurface(0).WriteText("TARGETING");Runtime.UpdateFrequency=UpdateFrequency.Update1;}public void Main(string argument,UpdateType updateSource){switch(argument){case"filter":onlyEnemies=!onlyEnemies;break;case"lock":var entity=TargetTracker.Scan(cam,5000,onlyEnemies);if(entity.HasValue){tt.LockOn(entity.Value);sound?.Play();}break;case"reset":tt.Clear();break;case"reload":welders.ForEach(w=>w.Enabled=true);break;case"init":var ids=new HashSet<long>(torpedos.Select(t=>t.EntityId));var groups=new List<IMyBlockGroup>();GridTerminalSystem.GetBlockGroups(groups,g=>g.Name.StartsWith("TORPEDO"));torpedos.AddRange(groups.Select(gr=>new Torpedo(gr)).Where(t=>!ids.Contains(t.EntityId)));torpedos.RemoveAll(t=>!t.IsAlive);welders.ForEach(w=>w.Enabled=false);break;case"start":torpedos.FirstOrDefault(t=>!t.Started)?.Start();break;default:tt.Update();if(sound?.IsWorking==true&&!tt.Current.HasValue){sound?.Stop();}torpedos?.ForEach(t=>t.Update(tt.Current));break;}UpdateSystemLcd();UpdateTargetLcd();UpdateWcLcd();UpdateTorpedoLcd(torpedos);}private void UpdateWcLcd(){radar.Update();lcd4.WriteText(radar.ToString());}void UpdateSystemLcd(){var filter=onlyEnemies?"Enemies":"All";var sb=new StringBuilder();sb.AppendLine($"Range: {cam.AvailableScanRange:0.0}");sb.AppendLine($"Cam count: {tt.Count}");sb.AppendLine($"Welders count: {welders.Count}");sb.AppendLine($"Filter: {filter}");lcd1.WriteText(sb.ToString());}void UpdateTargetLcd(){var sb=new StringBuilder();sb.AppendLine($"Locked: {tt.Current.HasValue}");if(tt.Current.HasValue){var target=tt.Current.Value.Entity;var distance=Vector3D.Distance(cam.GetPosition(),target.Position);sb.AppendLine($"- type: {target.Type}");sb.AppendLine($"- speed: {target.Velocity.Length():0.0}");sb.AppendLine($"- distance: {distance:0.0}");sb.AppendLine($"- position X: {target.Position.X:0.0}");sb.AppendLine($"- position Y: {target.Position.Y:0.0}");sb.AppendLine($"- position Z: {target.Position.Z:0.0}");}lcd2.WriteText(sb.ToString());}void UpdateTorpedoLcd(List<Torpedo>torpedos){var targetPos=tt.Current?.Entity.Position;var sb=new StringBuilder();for(var i=0;i<torpedos?.Count;i++){var t=torpedos[i];var myPos=t.Position;sb.Append($"{i+1} Speed: {t.Speed:0.0}");if(!t.Started){sb.Append(" Status: Ready");}else if(t.IsAlive){sb.Append(" Status: Active");}else{sb.Append(" Status: Dead");}if(targetPos!=null&&t.IsAlive){var distance=Vector3D.Distance(myPos,targetPos.Value);sb.Append($" Distance: {distance:0.0}");}sb.AppendLine();}lcd3.WriteText(sb.ToString());}
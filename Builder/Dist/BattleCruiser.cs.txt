//11/21/2023 12:47:32 AM
public class RuntimeTracker{public int Capacity{get;set;}public double MaxRuntime{get;private set;}public double MaxInstructions{get;private set;}public double AverageRuntime{get;private set;}public double AverageInstructions{get;private set;}public double LastRuntime{get;private set;}public double LastInstructions{get;private set;}readonly Queue<double>runtimes=new Queue<double>();readonly Queue<double>instructions=new Queue<double>();readonly int instructionLimit;readonly MyGridProgram program;double runtimeSum=0;double instructionsSum=0;public RuntimeTracker(MyGridProgram program,int capacity=120){this.program=program;Capacity=capacity;instructionLimit=program.Runtime.MaxInstructionCount;}public void AddRuntime(){LastRuntime=program.Runtime.LastRunTimeMs;runtimes.Enqueue(LastRuntime);runtimeSum+=LastRuntime;if(runtimes.Count>Capacity){var firstRuntime=runtimes.Dequeue();runtimeSum-=firstRuntime;}AverageRuntime=runtimeSum/runtimes.Count();MaxRuntime=runtimes.Max();}public void AddInstructions(){LastInstructions=program.Runtime.CurrentInstructionCount;instructions.Enqueue(LastInstructions);instructionsSum+=LastInstructions;if(instructions.Count>Capacity){var firstInstructions=instructions.Dequeue();instructionsSum-=firstInstructions;}AverageInstructions=instructionsSum/instructions.Count();MaxInstructions=instructions.Max();}public override string ToString(){return$"Runtime: {LastRuntime:0.00}ms/{AverageRuntime:0.00}ms/{MaxRuntime:0.00}ms\n"+$"Instructions: {LastInstructions:0}/{AverageInstructions:0}/{MaxInstructions:0}\n"+$"Complexity: {AverageInstructions:0}/{instructionLimit:0} ({AverageInstructions/instructionLimit:0.00}%)";}}public class RotorTurret{const int LAUNCHER_RELOAD_TIME=1000;const int ROTATION_RATIO=5;const int MAX_DISTANCE=800;const float THRESHOLD=0.1f;private IMyMotorStator rotorAzimuth;private IMyMotorStator rotorElevationL;private IMyMotorStator rotorElevationR;private IMyTerminalBlock container;private IMyLargeTurretBase designator;private int nextShotDelay;private DateTime nextShotTime=DateTime.MinValue;private int nextLauncher=0;private List<IMySmallMissileLauncher>launchers=new List<IMySmallMissileLauncher>();private double pi2=Math.PI*2;public bool Enabled{get;set;}public bool ShootingEnabled{get;set;}public double MinElevationRad{get;set;}=0;public double MaxElevationRad{get;set;}=Math.PI;private T GetBlock<T>(IEnumerable<IMyTerminalBlock>list,string prefix=null)where T:class,IMyTerminalBlock{return list.FirstOrDefault(b=>b is T&&(string.IsNullOrEmpty(prefix)||b.CustomName.StartsWith(prefix,StringComparison.CurrentCultureIgnoreCase)))as T;}public RotorTurret(IMyBlockGroup group){var tmp=new List<IMyTerminalBlock>();group.GetBlocks(tmp);rotorAzimuth=GetBlock<IMyMotorStator>(tmp,"AZIMUTH");rotorElevationL=GetBlock<IMyMotorStator>(tmp,"LEFT");rotorElevationR=GetBlock<IMyMotorStator>(tmp,"RIGHT");container=GetBlock<IMyTerminalBlock>(tmp,"BODY");designator=GetBlock<IMyLargeTurretBase>(tmp,"DESIGNATOR");group.GetBlocksOfType(launchers);nextShotDelay=launchers.Any()?(LAUNCHER_RELOAD_TIME/launchers.Count):0;}public void Update(){var invertedMatrix=MatrixD.Invert(rotorAzimuth.WorldMatrix.GetOrientation());var target=designator.GetTargetedEntity();if(Enabled&&!target.IsEmpty()){var myPos=container.GetPosition();var targetVector=target.Position-myPos;var targetVectorLocal=Vector3D.Transform(targetVector,invertedMatrix);bool isAimed=SetDirection(targetVectorLocal);bool isInRange=targetVectorLocal.Length()<MAX_DISTANCE;bool isInSector=CheckSector();if(ShootingEnabled&&isAimed&&isInRange&&isInSector){TryToShoot();}}else{SetDirection(new Vector3D(0,0,-1));}}private bool SetDirection(Vector3 targetVectorLocal){var azimuth=Math.Atan2(-targetVectorLocal.X,targetVectorLocal.Z);var elevation=Math.Asin(targetVectorLocal.Y/targetVectorLocal.Length());var azimuthDiff=NormalizeAngle(azimuth-rotorAzimuth.Angle);var elevationLDiff=NormalizeAngle(elevation-rotorElevationL.Angle);var elevationRDiff=NormalizeAngle(-elevation-rotorElevationR.Angle);rotorAzimuth.TargetVelocityRad=(float)(azimuthDiff*ROTATION_RATIO);rotorElevationL.TargetVelocityRad=(float)(elevationLDiff*ROTATION_RATIO);rotorElevationR.TargetVelocityRad=(float)(elevationRDiff*ROTATION_RATIO);var sameDirection=(Math.Abs(azimuthDiff)+Math.Abs(elevationLDiff)+Math.Abs(elevationRDiff))<THRESHOLD;return sameDirection;}private void TryToShoot(){var now=DateTime.UtcNow;if(now>nextShotTime){launchers[nextLauncher].ShootOnce();nextShotTime=now.AddMilliseconds(nextShotDelay);nextLauncher=(nextLauncher+1)%launchers.Count;}}private bool CheckSector(){var angleL=NormalizeAngle(rotorElevationL?.Angle);var angleR=NormalizeAngle(rotorElevationR?.Angle,true);var isInSector=angleL>=MinElevationRad&&angleL<MaxElevationRad&&angleR>=MinElevationRad&&angleR<MaxElevationRad;return isInSector;}private double NormalizeAngle(double?value,bool invert=false){var angle=invert?-value.GetValueOrDefault():value.GetValueOrDefault();if(double.IsNaN(angle)){return 0;}else if(angle<-Math.PI){return angle+pi2;}else if(angle>Math.PI){return angle-pi2;}return angle;}public static Vector3D GetAngularVelocities(Vector3D myLinearSpeed,Vector3D myAngularSpeed,Vector3D targetLinearSpeed,Vector3D targetVector){double sqR=Vector3D.Dot(targetVector,targetVector);if(sqR==0)return Vector3D.Zero;return myAngularSpeed-Vector3D.Cross(targetVector,targetLinearSpeed-myLinearSpeed)/sqR;}}readonly RuntimeTracker tracker;readonly IMyTextSurface lcd;readonly List<RotorTurret>turrets;public Program(){tracker=new RuntimeTracker(this);lcd=Me.GetSurface(1);lcd.ContentType=ContentType.TEXT_AND_IMAGE;var groups=new List<IMyBlockGroup>();GridTerminalSystem.GetBlockGroups(groups,g=>g.Name.StartsWith("TURRET"));turrets=groups.Select(gr=>new RotorTurret(gr){Enabled=true,ShootingEnabled=true}).ToList();}public void Main(string argument,UpdateType updateSource){tracker.AddRuntime();switch(argument.ToLower()){case"enable":turrets.ForEach(t=>t.Enabled=true);break;case"disable":turrets.ForEach(t=>t.Enabled=false);break;}turrets.ForEach(t=>t.Update());tracker.AddInstructions();lcd.WriteText(tracker.ToString());}
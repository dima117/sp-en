//11/23/2023 1:01:14 AM
public class RuntimeTracker{public int Capacity{get;set;}public double MaxRuntime{get;private set;}public double MaxInstructions{get;private set;}public double AverageRuntime{get;private set;}public double AverageInstructions{get;private set;}public double LastRuntime{get;private set;}public double LastInstructions{get;private set;}readonly Queue<double>runtimes=new Queue<double>();readonly Queue<double>instructions=new Queue<double>();readonly int instructionLimit;readonly MyGridProgram program;double runtimeSum=0;double instructionsSum=0;public RuntimeTracker(MyGridProgram program,int capacity=120){this.program=program;Capacity=capacity;instructionLimit=program.Runtime.MaxInstructionCount;}public void AddRuntime(){LastRuntime=program.Runtime.LastRunTimeMs;runtimes.Enqueue(LastRuntime);runtimeSum+=LastRuntime;if(runtimes.Count>Capacity){var firstRuntime=runtimes.Dequeue();runtimeSum-=firstRuntime;}AverageRuntime=runtimeSum/runtimes.Count();MaxRuntime=runtimes.Max();}public void AddInstructions(){LastInstructions=program.Runtime.CurrentInstructionCount;instructions.Enqueue(LastInstructions);instructionsSum+=LastInstructions;if(instructions.Count>Capacity){var firstInstructions=instructions.Dequeue();instructionsSum-=firstInstructions;}AverageInstructions=instructionsSum/instructions.Count();MaxInstructions=instructions.Max();}public override string ToString(){return$"Runtime: {LastRuntime:0.00}ms/{AverageRuntime:0.00}ms/{MaxRuntime:0.00}ms\n"+$"Instructions: {LastInstructions:0}/{AverageInstructions:0}/{MaxInstructions:0}\n"+$"Complexity: {AverageInstructions:0}/{instructionLimit:0} ({AverageInstructions/instructionLimit:0.00}%)";}}public static class Helpers{public class InterceptResult{public Vector3D Position;public double TimeMs;}public static InterceptResult CalculateInterceptPoint(Vector3D ownPosition,double interceptSpeed,Vector3D targetPosition,Vector3D targetVelocity){Vector3D directionToTarget=Vector3D.Normalize(targetPosition-ownPosition);double targetSpeedlOrth=Vector3D.Dot(targetVelocity,directionToTarget);Vector3D targetVelOrth=directionToTarget*targetSpeedlOrth;Vector3D targetVelTang=targetVelocity-targetVelOrth;double targetSpeedlTang=targetVelTang.Length();if(targetSpeedlTang>=interceptSpeed){return null;}double missileSpeedTang=targetSpeedlTang;double missileSpeedOrth=Math.Sqrt(interceptSpeed*interceptSpeed-missileSpeedTang*missileSpeedTang);if(targetSpeedlOrth>=missileSpeedOrth){return null;}double timeS=Vector3D.Distance(ownPosition,targetPosition)/(missileSpeedOrth-targetSpeedlOrth);Vector3D point=targetPosition+targetVelocity*timeS;return new InterceptResult{Position=point,TimeMs=timeS*1000};}}public class RotorTurret{const int LAUNCHER_RELOAD_TIME=1000;const int ROTATION_RATIO=20;const int MAX_DISTANCE=800;const float THRESHOLD=0.2f;private IMyMotorStator rotorAzimuth;private IMyMotorStator rotorElevationL;private IMyMotorStator rotorElevationR;private IMyTerminalBlock container;private IMyLargeTurretBase designator;private IMyShipController control;private int nextShotDelay;private DateTime nextShotTime=DateTime.MinValue;private int nextLauncher=0;private List<IMySmallMissileLauncher>launchers=new List<IMySmallMissileLauncher>();private List<IMySmallGatlingGun>gatlings=new List<IMySmallGatlingGun>();private double pi2=Math.PI*2;public bool Enabled{get;set;}public bool ShootingEnabled{get;set;}public double MinElevationRad{get;set;}=0;public double MaxElevationRad{get;set;}=Math.PI;private T GetBlock<T>(IEnumerable<IMyTerminalBlock>list,string prefix=null)where T:class,IMyTerminalBlock{return list.FirstOrDefault(b=>b is T&&(string.IsNullOrEmpty(prefix)||b.CustomName.StartsWith(prefix,StringComparison.CurrentCultureIgnoreCase)))as T;}public RotorTurret(IMyBlockGroup group){var tmp=new List<IMyTerminalBlock>();group.GetBlocks(tmp);rotorAzimuth=GetBlock<IMyMotorStator>(tmp,"AZIMUTH");rotorElevationL=GetBlock<IMyMotorStator>(tmp,"LEFT");rotorElevationR=GetBlock<IMyMotorStator>(tmp,"RIGHT");container=GetBlock<IMyTerminalBlock>(tmp,"BODY");designator=GetBlock<IMyLargeTurretBase>(tmp,"DESIGNATOR");control=GetBlock<IMyShipController>(tmp,"PPP");group.GetBlocksOfType(launchers);group.GetBlocksOfType(gatlings);nextShotDelay=launchers.Any()?(LAUNCHER_RELOAD_TIME/launchers.Count):0;}public void Update(){var invertedMatrix=MatrixD.Invert(rotorAzimuth.WorldMatrix.GetOrientation());var target=designator.GetTargetedEntity();if(Enabled&&!target.IsEmpty()){var myPos=container.GetPosition();var interceptPos=Helpers.CalculateInterceptPoint(myPos,198,target.Position,target.Velocity-control.GetShipVelocities().LinearVelocity);var targetVector=interceptPos.Position-myPos;var targetVectorLocal=Vector3D.Transform(targetVector,invertedMatrix);var targetVelocityLocal=Vector3D.Transform(target.Velocity,invertedMatrix);bool isAimed=SetDirection(targetVectorLocal,targetVelocityLocal);bool isInRange=targetVectorLocal.Length()<MAX_DISTANCE;bool isInSector=CheckSector();if(ShootingEnabled&&isAimed&&isInRange&&isInSector){TryToShoot();gatlings.ForEach(x=>x.Shoot=true);}else{gatlings.ForEach(x=>x.Shoot=false);}}else{rotorAzimuth.TargetVelocityRad=0;rotorElevationL.TargetVelocityRad=0;rotorElevationR.TargetVelocityRad=0;}}private bool SetDirection(Vector3D targetVectorLocal,Vector3D targetVelocityLocal){var invertedMatrix=MatrixD.Invert(rotorAzimuth.WorldMatrix.GetOrientation());var azimuth=Math.Atan2(-targetVectorLocal.X,targetVectorLocal.Z);var elevation=Math.Asin(targetVectorLocal.Y/targetVectorLocal.Length());var azimuthDiff=NormalizeAngle(azimuth-rotorAzimuth.Angle);var elevationLDiff=NormalizeAngle(elevation-rotorElevationL.Angle);var elevationRDiff=NormalizeAngle(-elevation-rotorElevationR.Angle);var v=control.GetShipVelocities();var myLinearVelocityLocal=Vector3D.Transform(v.LinearVelocity,invertedMatrix);var myAngularVelocityLocal=Vector3D.Transform(v.AngularVelocity,invertedMatrix);var targetAngularVelocity=GetAngularVelocities(myLinearVelocityLocal,myAngularVelocityLocal,targetVelocityLocal,targetVectorLocal);rotorAzimuth.TargetVelocityRad=(float)(azimuthDiff*ROTATION_RATIO)-Convert.ToSingle(targetAngularVelocity.Dot(rotorAzimuth.WorldMatrix.Up));rotorElevationL.TargetVelocityRad=(float)(elevationLDiff*ROTATION_RATIO)-Convert.ToSingle(targetAngularVelocity.Dot(rotorElevationL.WorldMatrix.Up));rotorElevationR.TargetVelocityRad=(float)(elevationRDiff*ROTATION_RATIO)-Convert.ToSingle(targetAngularVelocity.Dot(rotorElevationR.WorldMatrix.Up));var sameDirection=(Math.Abs(azimuthDiff)+Math.Abs(elevationLDiff)+Math.Abs(elevationRDiff))<THRESHOLD;return sameDirection;}private void TryToShoot(){var now=DateTime.UtcNow;if(now>nextShotTime){launchers[nextLauncher].ShootOnce();nextShotTime=now.AddMilliseconds(nextShotDelay);nextLauncher=(nextLauncher+1)%launchers.Count;}}private bool CheckSector(){var angleL=NormalizeAngle(rotorElevationL?.Angle);var angleR=NormalizeAngle(rotorElevationR?.Angle,true);var isInSector=angleL>=MinElevationRad&&angleL<MaxElevationRad&&angleR>=MinElevationRad&&angleR<MaxElevationRad;return isInSector;}private double NormalizeAngle(double?value,bool invert=false){var angle=invert?-value.GetValueOrDefault():value.GetValueOrDefault();if(double.IsNaN(angle)){return 0;}else if(angle<-Math.PI){return angle+pi2;}else if(angle>Math.PI){return angle-pi2;}return angle;}public static Vector3D GetAngularVelocities(Vector3D myLinearSpeed,Vector3D myAngularSpeed,Vector3D targetLinearSpeed,Vector3D targetVector){double sqR=Vector3D.Dot(targetVector,targetVector);if(sqR==0)return Vector3D.Zero;return myAngularSpeed-Vector3D.Cross(targetVector,targetLinearSpeed-myLinearSpeed)/sqR;}}readonly RuntimeTracker tracker;readonly IMyTextSurface lcd;readonly List<RotorTurret>turrets;public Program(){tracker=new RuntimeTracker(this);lcd=Me.GetSurface(1);lcd.ContentType=ContentType.TEXT_AND_IMAGE;var groups=new List<IMyBlockGroup>();GridTerminalSystem.GetBlockGroups(groups,g=>g.Name.StartsWith("TURRET"));turrets=groups.Select(gr=>new RotorTurret(gr){Enabled=true,ShootingEnabled=true,MinElevationRad=-Math.PI/10,}).ToList();Runtime.UpdateFrequency=UpdateFrequency.Update1;}public void Main(string argument,UpdateType updateSource){tracker.AddRuntime();switch(argument.ToLower()){case"enable":turrets.ForEach(t=>t.Enabled=true);break;case"disable":turrets.ForEach(t=>t.Enabled=false);break;}turrets.ForEach(t=>t.Update());tracker.AddInstructions();lcd.WriteText(tracker.ToString());}
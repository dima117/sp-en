//29-May-24 1:32:56 AM
public class RuntimeTracker{public int Capacity{get;set;}public double MaxRuntime{get;private set;}public double MaxInstructions{get;private set;}public double AverageRuntime{get;private set;}public double AverageInstructions{get;private set;}public double LastRuntime{get;private set;}public double LastInstructions{get;private set;}readonly Queue<double>runtimes=new Queue<double>();readonly Queue<double>instructions=new Queue<double>();readonly int instructionLimit;readonly MyGridProgram program;double runtimeSum=0;double instructionsSum=0;public RuntimeTracker(MyGridProgram program,int capacity=120){this.program=program;Capacity=capacity;instructionLimit=program.Runtime.MaxInstructionCount;}public void AddRuntime(){LastRuntime=program.Runtime.LastRunTimeMs;runtimes.Enqueue(LastRuntime);runtimeSum+=LastRuntime;if(runtimes.Count>Capacity){var firstRuntime=runtimes.Dequeue();runtimeSum-=firstRuntime;}AverageRuntime=runtimeSum/runtimes.Count();MaxRuntime=runtimes.Max();}public void AddInstructions(){LastInstructions=program.Runtime.CurrentInstructionCount;instructions.Enqueue(LastInstructions);instructionsSum+=LastInstructions;if(instructions.Count>Capacity){var firstInstructions=instructions.Dequeue();instructionsSum-=firstInstructions;}AverageInstructions=instructionsSum/instructions.Count();MaxInstructions=instructions.Max();}public override string ToString(){return$"Runtime: {LastRuntime:0.00}ms/{AverageRuntime:0.00}ms/{MaxRuntime:0.00}ms\n"+$"Instructions: {LastInstructions:0}/{AverageInstructions:0}/{MaxInstructions:0}\n"+$"Complexity: {AverageInstructions:0}/{instructionLimit:0} ({AverageInstructions/instructionLimit:0.00}%)";}}public class Grid{readonly IMyGridTerminalSystem system;public Grid(IMyGridTerminalSystem system){this.system=system;}public IMyBlockGroup[]GetBlockGroups(string prefix=""){var groups=new List<IMyBlockGroup>();system.GetBlockGroups(groups,g=>g.Name.StartsWith(prefix,StringComparison.OrdinalIgnoreCase));return groups.ToArray();}public T[]GetBlocksOfType<T>(Func<T,bool>filter=null)where T:class,IMyTerminalBlock{var list=new List<T>();system.GetBlocksOfType(list,filter);return list.ToArray();}public T GetBlockWithName<T>(string name)where T:class,IMyTerminalBlock{return system.GetBlockWithName(name)as T;}public IMyCameraBlock GetCamera(string name){var camera=GetBlockWithName<IMyCameraBlock>(name);if(camera!=null){camera.Enabled=true;camera.EnableRaycast=true;}return camera;}public IMySmallMissileLauncherReload[]GetLargeRailguns(Func<IMySmallMissileLauncherReload,bool>filter=null){return GetBlocksOfType<IMySmallMissileLauncherReload>(b=>b.BlockDefinition.SubtypeId=="LargeRailgun"&&(filter==null||filter(b))).ToArray();}public IMySmallMissileLauncher[]GetArtillery(Func<IMySmallMissileLauncher,bool>filter=null){return GetBlocksOfType<IMySmallMissileLauncher>(b=>b.BlockDefinition.SubtypeId=="LargeBlockLargeCalibreGun"&&(filter==null||filter(b))).ToArray();}public IMyLargeMissileTurret[]GetArtilleryTurrets(Func<IMyLargeMissileTurret,bool>filter=null){return GetBlocksOfType<IMyLargeMissileTurret>(b=>b.BlockDefinition.SubtypeId=="LargeCalibreTurret"&&(filter==null||filter(b))).ToArray();}public IMySoundBlock GetSound(string name,string soundName="SoundBlockAlert2"){var sound=GetBlockWithName<IMySoundBlock>(name);if(sound!=null){sound.Enabled=true;sound.SelectedSound=soundName;sound.Volume=1;sound.Range=100;}return sound;}public T GetByFilterOrAny<T>(Func<T,bool>filter=null,Action<T>init=null)where T:class,IMyTerminalBlock{var all=new List<T>();system.GetBlocksOfType(all,filter);T res=null;if(filter!=null){res=all.FirstOrDefault(filter);}if(res==null){res=all.FirstOrDefault();}if(res!=null&&init!=null){init(res);}return res;}}public static class Helpers{public class InterceptResult{public Vector3D Position;public double TimeMs;}public static InterceptResult CalculateInterceptPoint(Vector3D ownPosition,double interceptSpeed,Vector3D targetPosition,Vector3D targetVelocity){Vector3D directionToTarget=Vector3D.Normalize(targetPosition-ownPosition);double targetSpeedlOrth=Vector3D.Dot(targetVelocity,directionToTarget);Vector3D targetVelOrth=directionToTarget*targetSpeedlOrth;Vector3D targetVelTang=targetVelocity-targetVelOrth;double targetSpeedlTang=targetVelTang.Length();if(targetSpeedlTang>=interceptSpeed){return null;}double missileSpeedTang=targetSpeedlTang;double missileSpeedOrth=Math.Sqrt(interceptSpeed*interceptSpeed-missileSpeedTang*missileSpeedTang);if(targetSpeedlOrth>=missileSpeedOrth){return null;}double timeS=Vector3D.Distance(ownPosition,targetPosition)/(missileSpeedOrth-targetSpeedlOrth);Vector3D point=targetPosition+targetVelocity*timeS;return new InterceptResult{Position=point,TimeMs=timeS*1000};}}public class DirectionController2{public const double MIN_SPEED=50;public const float DEFAULT_FACTOR=2;readonly IMyShipController remoteControl;readonly IEnumerable<IMyGyro>gyroList;readonly float factor;public DirectionController2(IMyShipController remoteControl,IEnumerable<IMyGyro>gyroList,float factor=DEFAULT_FACTOR){this.remoteControl=remoteControl;this.gyroList=gyroList;this.factor=factor;}public void ICBM(MyDetectedEntityInfo target){var grav=remoteControl.GetNaturalGravity();var ownPos=remoteControl.GetPosition();var velocity=remoteControl.GetShipVelocities().LinearVelocity;var ownSpeed=Math.Max(velocity.Length(),MIN_SPEED);var point=Helpers.CalculateInterceptPoint(ownPos,ownSpeed,target.Position,target.Velocity);var targetPos=point==null?target.Position:point.Position;var targetVector=targetPos-ownPos;if(grav.IsZero()||targetVector.Length()<3500){Aim(targetPos);}else{Vector3D direction=CompensateSideVelocity(grav,targetVector);var axis=GetAxis(remoteControl.WorldMatrix.Forward,direction);SetGyroByAxis(axis,gyroList,factor);}}public void KeepHorizon(Vector3D?grav=null){var direction=grav??remoteControl.GetNaturalGravity();if(!direction.IsZero()){var axis=GetAxis(remoteControl.WorldMatrix.Down,direction);SetGyroByAxis(axis,gyroList,factor);}}public void Aim(Vector3D targetPos){var ownPos=remoteControl.GetPosition();var velocity=remoteControl.GetShipVelocities().LinearVelocity;var targetVector=CompensateSideVelocity(velocity,targetPos-ownPos);var axis=GetAxis(remoteControl.WorldMatrix.Forward,targetVector);SetGyroByAxis(axis,gyroList,factor);}public bool Intercept(Vector3D targetPosition,Vector3 targetVelocity){var ownPos=remoteControl.GetPosition();var velocity=remoteControl.GetShipVelocities().LinearVelocity;var ownSpeed=Math.Max(velocity.Length(),MIN_SPEED);var interceptPoint=Helpers.CalculateInterceptPoint(ownPos,ownSpeed,targetPosition,targetVelocity);var aimingPointPosition=interceptPoint?.Position??targetPosition;var direction=aimingPointPosition-ownPos;var compensatedTargetVector=CompensateSideVelocity(velocity,direction);var axis=GetAxis(remoteControl.WorldMatrix.Forward,compensatedTargetVector);SetGyroByAxis(axis,gyroList,factor);return interceptPoint!=null;}public bool InterceptShot(MyDetectedEntityInfo target,double bulletSpeed){var ownPos=remoteControl.GetPosition();var ownVelocity=remoteControl.GetShipVelocities().LinearVelocity;var relativeTargetVelocity=target.Velocity-ownVelocity;var point=Helpers.CalculateInterceptPoint(ownPos,bulletSpeed,target.Position,relativeTargetVelocity);var targetVector=point==null?(target.Position-ownPos):(point.Position-ownPos);var axis=GetAxis(remoteControl.WorldMatrix.Forward,targetVector);SetGyroByAxis(axis,gyroList,factor);return point!=null;}public static Vector3D CompensateSideVelocity(Vector3D velocity,Vector3D targetVector,float ratio=1){var sideVelocity=Vector3D.Reject(velocity,Vector3D.Normalize(targetVector));var sameDirection=Vector3D.Dot(velocity,targetVector)>0;return sameDirection?velocity-(1+ratio)*sideVelocity:(1-ratio)*sideVelocity-velocity;}public static Vector3D GetAxis(Vector3D currentDirection,Vector3D targetDirection){var target=Vector3D.Normalize(targetDirection);var current=Vector3D.Normalize(currentDirection);var axis=target.Cross(current);if(target.Dot(current)<0){axis=Vector3D.Normalize(axis);}return axis;}public static void SetGyroByAxis(Vector3D axis,IEnumerable<IMyGyro>gyroList,float factor=DEFAULT_FACTOR){foreach(var gyro in gyroList){gyro.Yaw=factor*Convert.ToSingle(axis.Dot(gyro.WorldMatrix.Up));gyro.Pitch=factor*Convert.ToSingle(axis.Dot(gyro.WorldMatrix.Right));gyro.Roll=factor*Convert.ToSingle(axis.Dot(gyro.WorldMatrix.Backward));}}}public class BlockArray<T>where T:class,IMyTerminalBlock{MyGridProgram program;Action<T>init;private List<T>list=new List<T>();private int index=0;public int Count=>list.Count;public T1 Aggregate<T1>(T1 a,Func<T1,T,T1>fn)=>list.Aggregate(a,fn);public BlockArray(MyGridProgram program,Action<T>init=null){this.program=program;this.init=init;UpdateBlocks();}public void UpdateBlocks(){index=0;list=new List<T>();program.GridTerminalSystem.GetBlocksOfType(list);list.ForEach(init);}public void ForEach(Action<T>fn=null){if(fn!=null){list.ForEach(fn);}}public T GetNext(Func<T,bool>filter=null){for(var count=0;count<list.Count;count++){index++;if(index>=list.Count){index=0;}T block=list[index];if(filter==null||filter(block)){return block;}}return null;}}public class TargetInfo{const int HIT_POINT_DEPTH=5;public MyDetectedEntityInfo Entity{get;private set;}public DateTime Timestamp{get;private set;}public DateTime NextScan{get;private set;}public Vector3D HitPosRelative{get;private set;}public Vector3D GetHitPosWorld(){return Entity.Position+Vector3D.Transform(HitPosRelative,Entity.Orientation);}public TargetInfo(MyDetectedEntityInfo entity=default(MyDetectedEntityInfo),DateTime timestamp=default(DateTime),DateTime nextScan=default(DateTime),Vector3D hitPosRelative=default(Vector3D)){Entity=entity;Timestamp=timestamp;NextScan=nextScan;HitPosRelative=hitPosRelative;}public TargetInfo Update(MyDetectedEntityInfo entity,DateTime timestamp,DateTime nextScan){Entity=entity;Timestamp=timestamp;NextScan=nextScan;return this;}public void UpdateNextScan(DateTime nextScan){NextScan=nextScan;}public static TargetInfo CreateTargetInfo(MyDetectedEntityInfo entity,Vector3D camPos,DateTime timestamp,DateTime?nextScan=null){var relativeHitPos=default(Vector3D);if(entity.HitPosition.HasValue){var hitPos=entity.HitPosition.Value;var correctedHitPos=hitPos+Vector3D.Normalize(hitPos-camPos)*HIT_POINT_DEPTH;var invertedMatrix=MatrixD.Invert(entity.Orientation);relativeHitPos=Vector3D.Transform(correctedHitPos-entity.Position,invertedMatrix);}return new TargetInfo(entity,timestamp,nextScan??timestamp,relativeHitPos);}}public class TargetTracker{const int SCAN_DELAY_MS=60;const double DISTANCE_SCAN_DEFAULT=8000;static readonly HashSet<MyDetectedEntityType>targetTypes=new HashSet<MyDetectedEntityType>{MyDetectedEntityType.SmallGrid,MyDetectedEntityType.LargeGrid};public static TargetInfo Scan(IMyCameraBlock cam,double distance=DISTANCE_SCAN_DEFAULT,bool onlyEnemies=false){if(cam==null){return null;}var target=cam.Raycast(distance);if(target.IsEmpty()){return null;}if(!targetTypes.Contains(target.Type)){return null;}if(onlyEnemies&&target.Relationship!=MyRelationsBetweenPlayerAndBlock.Enemies){return null;}var camPos=cam.GetPosition();return TargetInfo.CreateTargetInfo(target,camPos,DateTime.UtcNow);}private BlockArray<IMyCameraBlock>camArray;public TargetInfo Current;static Vector3D CalculateTargetLocation(TargetInfo info,TimeSpan timePassed){var target=info.Entity;return info.GetHitPosWorld()+(target.Velocity*Convert.ToSingle(timePassed.TotalSeconds));}public TargetTracker(MyGridProgram program){camArray=new BlockArray<IMyCameraBlock>(program,cam=>{cam.Enabled=true;cam.EnableRaycast=true;});}public int Count{get{return camArray.Count;}}public double TotalRange{get{return camArray.Aggregate<double>(0,(a,c)=>a+c.AvailableScanRange);}}public void UpdateCamArray(){camArray.UpdateBlocks();}public void LockOn(TargetInfo target){Current=target;}public void Clear(){Current=null;}private MyDetectedEntityInfo TryGetUpdatedEntity(TargetInfo prevTarget,TimeSpan timePassed,DateTime now){var calculatedTargetPos=CalculateTargetLocation(prevTarget,timePassed);var camera=camArray.GetNext(cam=>cam.CanScan(calculatedTargetPos));if(camera==null){return default(MyDetectedEntityInfo);}var target=camera.Raycast(calculatedTargetPos);if(target.EntityId!=prevTarget.Entity.EntityId){return default(MyDetectedEntityInfo);}return target;}public void Update(){if(Current==null){return;}var now=DateTime.UtcNow;var prevTarget=Current;if(now<prevTarget.NextScan){return;}var timePassed=now-prevTarget.Timestamp;var target=TryGetUpdatedEntity(prevTarget,timePassed,now);if(target.IsEmpty()){if(timePassed.TotalSeconds>2){Clear();}}else{Current.Update(target,now,now.AddMilliseconds(SCAN_DELAY_MS));}}}readonly IMyTextSurface lcd;readonly Grid grid;readonly DirectionController2 dc;readonly TargetTracker tt;readonly IMyCameraBlock cam;readonly IMyCockpit cockpit;readonly List<IMyGyro>listGyro=new List<IMyGyro>();readonly List<IMyThrust>listEngine=new List<IMyThrust>();bool started=false;public Program(){grid=new Grid(GridTerminalSystem);cam=grid.GetCamera("camera_main");tt=new TargetTracker(this);cockpit=grid.GetByFilterOrAny<IMyCockpit>();GridTerminalSystem.GetBlocksOfType(listGyro);GridTerminalSystem.GetBlocksOfType(listEngine);dc=new DirectionController2(cockpit,listGyro);lcd=grid.GetBlockWithName<IMyTextPanel>("lcd");lcd.ContentType=ContentType.TEXT_AND_IMAGE;Runtime.UpdateFrequency=UpdateFrequency.Update1;}public void Main(string argument,UpdateType updateSource){switch(argument){case"lock":var target=TargetTracker.Scan(cam,7000,false);if(target!=null){tt.LockOn(target);}break;case"reset":tt.Clear();break;case"start":listGyro.ForEach(g=>{g.Enabled=true;g.GyroOverride=true;});listEngine.ForEach(e=>{e.Enabled=true;e.ThrustOverridePercentage=1;});started=true;break;default:tt.Update();if(started){Update(tt.Current);}break;}var sb=new StringBuilder();sb.AppendLine(tt.Current==null?"NO TARGET":"AIMED");sb.AppendLine($"count: {tt.Count}");sb.AppendLine($"gyro: {listGyro.Count}");lcd.WriteText(sb);}const double INTERCEPT_DISTANCE=1200;public void Update(TargetInfo target){double distance=0;if(target!=null){distance=(target.Entity.Position-cockpit.GetPosition()).Length();SetDirection(target,distance);}}void SetDirection(TargetInfo targetInfo,double distance){var targetPos=targetInfo.GetHitPosWorld();if(distance<INTERCEPT_DISTANCE){dc.Intercept(targetPos,targetInfo.Entity.Velocity);}else{dc.Aim(targetPos);}}
//3/20/2024 7:57:14 PM
public class RuntimeTracker{public int Capacity{get;set;}public double MaxRuntime{get;private set;}public double MaxInstructions{get;private set;}public double AverageRuntime{get;private set;}public double AverageInstructions{get;private set;}public double LastRuntime{get;private set;}public double LastInstructions{get;private set;}readonly Queue<double>runtimes=new Queue<double>();readonly Queue<double>instructions=new Queue<double>();readonly int instructionLimit;readonly MyGridProgram program;double runtimeSum=0;double instructionsSum=0;public RuntimeTracker(MyGridProgram program,int capacity=120){this.program=program;Capacity=capacity;instructionLimit=program.Runtime.MaxInstructionCount;}public void AddRuntime(){LastRuntime=program.Runtime.LastRunTimeMs;runtimes.Enqueue(LastRuntime);runtimeSum+=LastRuntime;if(runtimes.Count>Capacity){var firstRuntime=runtimes.Dequeue();runtimeSum-=firstRuntime;}AverageRuntime=runtimeSum/runtimes.Count();MaxRuntime=runtimes.Max();}public void AddInstructions(){LastInstructions=program.Runtime.CurrentInstructionCount;instructions.Enqueue(LastInstructions);instructionsSum+=LastInstructions;if(instructions.Count>Capacity){var firstInstructions=instructions.Dequeue();instructionsSum-=firstInstructions;}AverageInstructions=instructionsSum/instructions.Count();MaxInstructions=instructions.Max();}public override string ToString(){return$"Runtime: {LastRuntime:0.00}ms/{AverageRuntime:0.00}ms/{MaxRuntime:0.00}ms\n"+$"Instructions: {LastInstructions:0}/{AverageInstructions:0}/{MaxInstructions:0}\n"+$"Complexity: {AverageInstructions:0}/{instructionLimit:0} ({AverageInstructions/instructionLimit:0.00}%)";}}public class Grid{readonly IMyGridTerminalSystem system;public Grid(IMyGridTerminalSystem system){this.system=system;}public IMyBlockGroup[]GetBlockGroups(string prefix=""){var groups=new List<IMyBlockGroup>();system.GetBlockGroups(groups,g=>g.Name.StartsWith(prefix,StringComparison.OrdinalIgnoreCase));return groups.ToArray();}public T[]GetBlocksOfType<T>(Func<T,bool>filter=null)where T:class,IMyTerminalBlock{var list=new List<T>();system.GetBlocksOfType(list,filter);return list.ToArray();}public T GetBlockWithName<T>(string name)where T:class,IMyTerminalBlock{return system.GetBlockWithName(name)as T;}public IMyCameraBlock GetCamera(string name){var camera=GetBlockWithName<IMyCameraBlock>(name);if(camera!=null){camera.Enabled=true;camera.EnableRaycast=true;}return camera;}public IMySoundBlock GetSound(string name,string soundName="SoundBlockAlert2"){var sound=GetBlockWithName<IMySoundBlock>(name);if(sound!=null){sound.Enabled=true;sound.SelectedSound=soundName;sound.Volume=1;sound.Range=100;}return sound;}public T GetByFilterOrAny<T>(Func<T,bool>filter=null,Action<T>init=null)where T:class,IMyTerminalBlock{var all=new List<T>();system.GetBlocksOfType(all,filter);T res=null;if(filter!=null){res=all.FirstOrDefault(filter);}if(res==null){res=all.FirstOrDefault();}if(res!=null&&init!=null){init(res);}return res;}}public static class Helpers{public class InterceptResult{public Vector3D Position;public double TimeMs;}public static InterceptResult CalculateInterceptPoint(Vector3D ownPosition,double interceptSpeed,Vector3D targetPosition,Vector3D targetVelocity){Vector3D directionToTarget=Vector3D.Normalize(targetPosition-ownPosition);double targetSpeedlOrth=Vector3D.Dot(targetVelocity,directionToTarget);Vector3D targetVelOrth=directionToTarget*targetSpeedlOrth;Vector3D targetVelTang=targetVelocity-targetVelOrth;double targetSpeedlTang=targetVelTang.Length();if(targetSpeedlTang>=interceptSpeed){return null;}double missileSpeedTang=targetSpeedlTang;double missileSpeedOrth=Math.Sqrt(interceptSpeed*interceptSpeed-missileSpeedTang*missileSpeedTang);if(targetSpeedlOrth>=missileSpeedOrth){return null;}double timeS=Vector3D.Distance(ownPosition,targetPosition)/(missileSpeedOrth-targetSpeedlOrth);Vector3D point=targetPosition+targetVelocity*timeS;return new InterceptResult{Position=point,TimeMs=timeS*1000};}}public class DirectionController2{public const double MIN_SPEED=50;public const float DEFAULT_FACTOR=2;readonly IMyShipController remoteControl;readonly IEnumerable<IMyGyro>gyroList;readonly float factor;public DirectionController2(IMyShipController remoteControl,IEnumerable<IMyGyro>gyroList,float factor=DEFAULT_FACTOR){this.remoteControl=remoteControl;this.gyroList=gyroList;this.factor=factor;}public void ICBM(MyDetectedEntityInfo target){var grav=remoteControl.GetNaturalGravity();var ownPos=remoteControl.GetPosition();var velocity=remoteControl.GetShipVelocities().LinearVelocity;var ownSpeed=Math.Max(velocity.Length(),MIN_SPEED);var point=Helpers.CalculateInterceptPoint(ownPos,ownSpeed,target.Position,target.Velocity);var targetPos=point==null?target.Position:point.Position;var targetVector=targetPos-ownPos;if(grav.IsZero()||targetVector.Length()<3500){Aim(targetPos);}else{Vector3D direction=CompensateSideVelocity(grav,targetVector);var axis=GetAxis(remoteControl.WorldMatrix.Forward,direction);SetGyroByAxis(axis,gyroList,factor);}}public void KeepHorizon(Vector3D?grav=null){var direction=grav??remoteControl.GetNaturalGravity();if(!direction.IsZero()){var axis=GetAxis(remoteControl.WorldMatrix.Down,direction);SetGyroByAxis(axis,gyroList,factor);}}public void Aim(Vector3D targetPos){var ownPos=remoteControl.GetPosition();var velocity=remoteControl.GetShipVelocities().LinearVelocity;var targetVector=CompensateSideVelocity(velocity,targetPos-ownPos);var axis=GetAxis(remoteControl.WorldMatrix.Forward,targetVector);SetGyroByAxis(axis,gyroList,factor);}public bool Intercept(Vector3D targetPosition,Vector3 targetVelocity){var ownPos=remoteControl.GetPosition();var velocity=remoteControl.GetShipVelocities().LinearVelocity;var ownSpeed=Math.Max(velocity.Length(),MIN_SPEED);var interceptPoint=Helpers.CalculateInterceptPoint(ownPos,ownSpeed,targetPosition,targetVelocity);var aimingPointPosition=interceptPoint?.Position??targetPosition;var direction=aimingPointPosition-ownPos;var compensatedTargetVector=CompensateSideVelocity(velocity,direction);var axis=GetAxis(remoteControl.WorldMatrix.Forward,compensatedTargetVector);SetGyroByAxis(axis,gyroList,factor);return interceptPoint!=null;}public bool InterceptShot(MyDetectedEntityInfo target,double bulletSpeed){var ownPos=remoteControl.GetPosition();var ownVelocity=remoteControl.GetShipVelocities().LinearVelocity;var relativeTargetVelocity=target.Velocity-ownVelocity;var point=Helpers.CalculateInterceptPoint(ownPos,bulletSpeed,target.Position,relativeTargetVelocity);var targetVector=point==null?(target.Position-ownPos):(point.Position-ownPos);var axis=GetAxis(remoteControl.WorldMatrix.Forward,targetVector);SetGyroByAxis(axis,gyroList,factor);return point!=null;}public static Vector3D CompensateSideVelocity(Vector3D velocity,Vector3D targetVector,float ratio=1){var sideVelocity=Vector3D.Reject(velocity,Vector3D.Normalize(targetVector));var sameDirection=Vector3D.Dot(velocity,targetVector)>0;return sameDirection?velocity-(1+ratio)*sideVelocity:(1-ratio)*sideVelocity-velocity;}public static Vector3D GetAxis(Vector3D currentDirection,Vector3D targetDirection){var target=Vector3D.Normalize(targetDirection);var current=Vector3D.Normalize(currentDirection);var axis=target.Cross(current);if(target.Dot(current)<0){axis=Vector3D.Normalize(axis);}return axis;}public static void SetGyroByAxis(Vector3D axis,IEnumerable<IMyGyro>gyroList,float factor=DEFAULT_FACTOR){foreach(var gyro in gyroList){gyro.Yaw=factor*Convert.ToSingle(axis.Dot(gyro.WorldMatrix.Up));gyro.Pitch=factor*Convert.ToSingle(axis.Dot(gyro.WorldMatrix.Right));gyro.Roll=factor*Convert.ToSingle(axis.Dot(gyro.WorldMatrix.Backward));}}}class PrintState{public int index=0;public Vector3D position;public Vector3D[]points;}class X<T>where T:IMyTerminalBlock{public readonly T[]up;public readonly T[]down;public readonly T[]left;public readonly T[]right;public readonly T[]forward;public readonly T[]back;public readonly T[]all;public X(MatrixD anchor,IEnumerable<T>blocks,Func<MatrixD,Vector3D>fn){all=blocks.ToArray();forward=all.Where(b=>anchor.Forward==fn(b.WorldMatrix)).ToArray();back=all.Where(b=>anchor.Backward==fn(b.WorldMatrix)).ToArray();up=all.Where(b=>anchor.Up==fn(b.WorldMatrix)).ToArray();down=all.Where(b=>anchor.Down==fn(b.WorldMatrix)).ToArray();left=all.Where(b=>anchor.Left==fn(b.WorldMatrix)).ToArray();right=all.Where(b=>anchor.Right==fn(b.WorldMatrix)).ToArray();}public override string ToString(){return$"- up: {up.Length}, down: {down.Length}\n"+$"- left: {left.Length}, right: {right.Length}\n"+$"- forward: {forward.Length}, back: {back.Length}";}}class OneDimensionMovementController{private readonly IMyThrust[]forward;private readonly IMyThrust[]back;public OneDimensionMovementController(IMyThrust[]forward,IMyThrust[]back){this.forward=forward;this.back=back;}public static bool ControlThrusters(float mass,IMyThrust[]forward,IMyThrust[]back,double velocity,double distance){var fPercent=0f;var bPercent=0f;const float vT=1.5f;var fa=forward.Sum(t=>t.MaxThrust)/mass;var ba=back.Sum(t=>t.MaxThrust)/mass;if(velocity<0){fPercent=1;}else{var t=velocity/ba;var s=(velocity*t)-ba*t*t/2;if(s>=distance){bPercent=1;}else if(velocity<vT){fPercent=1;}}foreach(var t in forward){t.ThrustOverridePercentage=fPercent;}foreach(var t in back){t.ThrustOverridePercentage=bPercent;}return distance>0.2f&&Math.Abs(velocity)>0.2f;}public bool Update(float mass,double velocity,double currentPos,double targetPos){if(targetPos>currentPos){return ControlThrusters(mass,forward,back,velocity,targetPos-currentPos);}else{return ControlThrusters(mass,back,forward,-velocity,currentPos-targetPos);}}}const float FACTOR=1.4f;readonly IMyCockpit cockpit;readonly IMyGyro[]gyros;readonly IMyShipConnector connector;readonly RuntimeTracker tracker;readonly IMyTextSurface lcd;readonly IMyTextSurface lcdStatus;private readonly Grid grid;private readonly X<IMyThrust>thrusters;private readonly OneDimensionMovementController moveV;private readonly OneDimensionMovementController moveH;private Vector3D?directionDown;private Vector3D?directionForward;private PrintState printState;private bool sameGrid<T>(T b)where T:IMyTerminalBlock{return b.CubeGrid==Me.CubeGrid;}public Program(){grid=new Grid(GridTerminalSystem);tracker=new RuntimeTracker(this);lcd=Me.GetSurface(1);lcd.ContentType=ContentType.TEXT_AND_IMAGE;connector=grid.GetBlocksOfType<IMyShipConnector>(sameGrid).First();cockpit=grid.GetBlocksOfType<IMyCockpit>(sameGrid).First();gyros=grid.GetBlocksOfType<IMyGyro>(sameGrid);var t=grid.GetBlocksOfType<IMyThrust>(sameGrid);thrusters=new X<IMyThrust>(cockpit.WorldMatrix,t,m=>m.Backward);moveV=new OneDimensionMovementController(thrusters.up,thrusters.down);moveH=new OneDimensionMovementController(thrusters.right,thrusters.left);lcdStatus=cockpit.GetSurface(0);var x=Vector3D.Zero;var lines=Me.CustomData.Split('\n');if(lines.Length==2){if(!Vector3D.TryParse(lines[0],out x)){directionDown=x;}if(!Vector3D.TryParse(lines[1],out x)){directionForward=x;}}Runtime.UpdateFrequency=UpdateFrequency.Update1;}private void SetDirection(){if(connector.Status==MyShipConnectorStatus.Connected){var cubeGrid=connector.OtherConnector.CubeGrid;IMyShipController cockpit=grid.GetBlocksOfType<IMyShipController>(w=>w.CubeGrid==cubeGrid).FirstOrDefault();directionDown=cockpit?.WorldMatrix.Down;directionForward=cockpit?.WorldMatrix.Forward;if(directionDown.HasValue&&directionForward.HasValue){Me.CustomData=directionDown.ToString()+"\n"+directionForward.ToString();}else{Me.CustomData=string.Empty;}}}private void Lock(){if(directionDown.HasValue){connector.Disconnect();foreach(var gyro in gyros){gyro.GyroOverride=true;gyro.GyroPower=1;}}}private void Unlock(){foreach(var gyro in gyros){gyro.GyroOverride=false;gyro.GyroPower=0.3f;}}private void ControlThrusters(float mass,IMyThrust[]forward,IMyThrust[]back,double velocity,double distance){var fPercent=0f;var bPercent=0f;const float vT=1.5f;var ft=forward;var bt=back;var v0=velocity;var d=distance;if(distance<0){ft=back;bt=forward;v0=-velocity;d=-distance;}var fa=ft.Sum(t=>t.MaxThrust)/mass;var ba=bt.Sum(t=>t.MaxThrust)/mass;if(v0<0){fPercent=1;}else{var t=v0/ba;var s=(v0*t)-ba*t*t/2;if(s>=d){bPercent=1;}else if(v0<vT){fPercent=1;}}foreach(var t in ft){t.ThrustOverridePercentage=fPercent;}foreach(var t in bt){t.ThrustOverridePercentage=bPercent;}}private void Move(){if(printState==null){return;}if(printState.index<0||printState.index>=printState.points.Length){return;}var mass=cockpit.CalculateShipMass().TotalMass;var velocity=cockpit.GetShipVelocities().LinearVelocity;var matrix=MatrixD.Invert(cockpit.WorldMatrix.GetOrientation());var target=printState.points[printState.index];var offset=cockpit.GetPosition()-printState.position;var targetLocal=Vector3D.Transform(target,matrix);var offsetLocal=Vector3D.Transform(offset,matrix);var velocityLocal=Vector3D.Transform(velocity,matrix);if(moveV.Update(mass,velocityLocal.Y,offsetLocal.Y,targetLocal.Y)){return;}if(moveH.Update(mass,velocityLocal.X,offsetLocal.X,targetLocal.X)){return;}printState.index++;}private void Align(){if(directionDown.HasValue&&directionForward.HasValue){var axisDown=DirectionController2.GetAxis(cockpit.WorldMatrix.Down,directionDown.Value);var axisForward=DirectionController2.GetAxis(cockpit.WorldMatrix.Forward,directionForward.Value);foreach(var gyro in gyros){gyro.Yaw=FACTOR*Convert.ToSingle(axisForward.Dot(gyro.WorldMatrix.Up));gyro.Pitch=FACTOR*Convert.ToSingle(axisDown.Dot(gyro.WorldMatrix.Right));gyro.Roll=FACTOR*Convert.ToSingle(axisDown.Dot(gyro.WorldMatrix.Backward));gyro.GyroOverride=true;}}}public void Main(string argument,UpdateType updateSource){tracker.AddRuntime();switch(argument){case"init":SetDirection();Lock();break;case"reset":directionDown=null;directionForward=null;Me.CustomData=string.Empty;Unlock();break;case"start":Start(20,50);foreach(var t in thrusters.all){t.Enabled=true;}break;case"stop":printState=null;foreach(var t in thrusters.all){t.ThrustOverride=0;}break;}Align();Move();var sb=new StringBuilder();sb.AppendLine($"Locked: {directionDown.HasValue&&directionForward.HasValue}");sb.AppendLine($"Move: {printState!=null}");sb.AppendLine($"Point:\n{printState?.index??0:0}");lcdStatus.WriteText(sb);tracker.AddInstructions();lcd.WriteText(tracker.ToString());}private void Start(int width,int length){var STEP=2.5;var offset=Math.Ceiling(width/2f)*STEP;var pos=cockpit.GetPosition();var m=cockpit.WorldMatrix;var left=m.Left*offset;var right=m.Right*offset;var up=m.Up*STEP;var list=new List<Vector3D>();for(var level=0;level<length;level++){var pos1=pos+level*up;list.Add(pos1+right);list.Add(pos1+left);list.Add(pos1+right);list.Add(pos1+left);list.Add(pos1);list.Add(pos1+up);}directionDown=m.Down;directionForward=m.Forward;printState=new PrintState{position=pos,points=list.ToArray()};}private string FormatGPS(Vector3D point,string label){return$"GPS:{label}:{point.X:0.00}:{point.Y:0.00}:{point.Z:0.00}:#FF89F175:";}